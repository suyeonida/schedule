#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "schedule.h"
#include "linkedList.h"
#define STRING_SIZE 256
/* run this program using the console pauser or add your own getch, system("pause") or input loop */

int main(int argc, char *argv[]) {
	
	int exit_flag = 0;
	FILE *fp;          //파일 포인터  
	
	char name[200];
	char place[100], typeName[100];	
	size_t size;          //이건 뭘까?????? 
	int month;
	int day;
	int type;
	void *list;
	void *ndPtr;   //노드 포인터  
	void *schedInfo;
	int option;    //몇번 누르는지 확인  
	int cnt=1;
	
	struct genSchedInfo{
			char name[200];
			char place[200];
			char typeName[100];
			int month;
			int day;
			int type;
		};
		
	//1. FILE pointer open & error handling 
	fp= fopen("schedule.dat","r");  //파일 읽기모드로 열기	 
	if(fp == NULL){                //error handling 
		printf("invalid path! \n");
		return -1;
	}
	
	//fill code here ----
	
	//initializing the list    초기 상태 설정  
	printf("Reading the data files... \n");
	list = (void*)list_genList();    //list포인터에  
	
	//2. read from the file  파일로부터 정보들을 읽어와라. 
	while ( /* fill code here -- read from the file*/ )  //파일 읽어라.   //while이 왜 필요할까? 
	{	
		//fill code here -- generate genSchedInfo structure by genSchedInfo function  함수만들어야할까? 
		
		struct genSchedInfo m[10]; 
		int i;
		//파일 오픈은 앞에서 함. 
		//put the scheduling info instance generated by genSchedInfo function
		for(i=0;i<10;i++){
			fscanf("%s %s %s %d %d %d",&m[i].name,&m[i].place, &m[i].typeName, &m[i].month, &m[i].day, &m[i].type);
			fclose(fp);
		}
		list_addTail(schedInfo, list);   //add a node at the end of the list
	}
	
	
	//fill code here ---- close the file pointer
	fclose(fp);
	printf("Read done! %i schedules are read\n", list_len(list));
	
	
	//program starts
	while(exit_flag == 0) 
	{
		//3. menu printing
		printf("1.print all the schedules\n");
		printf("2.search for the schedules in the month\n");
		printf("3.search for the schedules in the place\n");
		printf("4.search for specific type schedule\n");
		printf("5.exit\n\n");
		printf(" select an option.");
		
		//4. get option from keyboard
		scanf("%d", &option);
		
		
		switch(option)
		{
			case 1: //print all the schedules   
				printf("printing all the schedules in the scheduler.....\n\n\n");
				
				ndPtr = list;
				while (list_isEndNode(ndPtr) == 0)
				{   
					printf("%d",cnt);  //print count
					//file code here -- print count and each scheduling info element
					sched_print(void* obj);
					cnt++;
					}
					
					ndPtr = list_getNextNd(ndPtr); //get the next node from the list  e
					schedInfo = list_getNdObj(ndPtr); //get the object (scheduling info)schedInfo는 포인터다.returns the object of the node
					
					//fill code this part - end
					
				}
				
				break;
				
			case 2:  //scanf로 2를 받는 다면  
				printf("which month ? : ");
				scanf("%i", &month);        //month에 숫자를 받음  
				
				ndPtr = list;
				while (list_isEndNode(ndPtr) == 0)
				{
				//file code here -- print scheduling info elements matching to the month
				int num=0;
				for()
				 
				//입력 파일이 유효한 경우 
				while(다 찾을 때까지 )
				
					printf("---------------------------------\n");
					printf("%d. Schedule Name : %s (%s)\n", cnt+1, m[cnt].place, m[cnt].typeName);
					printf("When : &d. %d",m[cnt].month, m[cnt].day);
					prinrf("Where : %s", m[cnt].place);
					
					
					ndPtr = list_getNextNd(ndPtr); //get the next node from the list
					schedInfo = list_getNdObj(ndPtr); //get the object (scheduling info)
					
					//fill code this part - end
				}
				
				break;
				
			case 3: // 3을 return 한다면 
				printf("which place ? : ");
				scanf("%s", &place);
				
				ndPtr = list;
				while (list_isEndNode(ndPtr) == 0)
				{
					//file code here -- print scheduling info elements matching to the place
					ndPtr = list_getNextNd(ndPtr); //get the next node from the list
					schedInfo = list_getNdObj(ndPtr); //get the object (scheduling info)
					
					//fill code this part - end
				}
				
				break;
				
			case 4:  //4를 return 한다면  
				printf("which type ?\n");
				sched_printTypes();
				printf("your choice : ");
				scanf("%s", &typeName);
				
				if (/* fill code here -- convert the type and check if the type is valid */)
				{
					ndPtr = list;
					while (list_isEndNode(ndPtr) == 0)
					{
						//file code here -- print scheduling info elements matching to the place
						ndPtr = list_getNextNd(ndPtr); //get the next node from the list
						schedInfo = list_getNdObj(ndPtr); //get the object (scheduling info)
						
						//fill code this part - end
					}
				}
				else
				{
					printf("wrong type name!\n");
				}
				break;
				
			case 5:  //5를 return 한다면 프로그램 exit 
				printf("Bye!\n\n");
				exit_flag = 1;
				break;
				
			default:  //아무것도 아니라면  
				printf("wrong command! input again\n");
				break;
		}
		
		
	}
	
	return 0;
}
